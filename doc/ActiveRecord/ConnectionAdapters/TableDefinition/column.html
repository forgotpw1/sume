<h1>ActiveRecord::ConnectionAdapters::TableDefinition#column</h1>

Instantiates a new column for the table.
The +type+ parameter is normally one of the migrations native types,
which is one of the following:
<tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>,
<tt>:integer</tt>, <tt>:float</tt>, <tt>:decimal</tt>,
<tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>,
<tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>.

You may use a type not in this list as long as it is supported by your
database (for example, "polygon" in MySQL), but this will not be database
agnostic and should usually be avoided.

Available options are (none of these exists by default):
* <tt>:limit</tt> -
  Requests a maximum column length. This is number of characters for <tt>:string</tt> and
  <tt>:text</tt> columns and number of bytes for <tt>:binary</tt> and <tt>:integer</tt> columns.
* <tt>:default</tt> -
  The column's default value. Use nil for NULL.
* <tt>:null</tt> -
  Allows or disallows +NULL+ values in the column. This option could
  have been named <tt>:null_allowed</tt>.
* <tt>:precision</tt> -
  Specifies the precision for a <tt>:decimal</tt> column.
* <tt>:scale</tt> -
  Specifies the scale for a <tt>:decimal</tt> column.

For clarity's sake: the precision is the number of significant digits,
while the scale is the number of digits that can be stored following
the decimal point. For example, the number 123.45 has a precision of 5
and a scale of 2. A decimal with a precision of 5 and a scale of 2 can
range from -999.99 to 999.99.

Please be aware of different RDBMS implementations behavior with
<tt>:decimal</tt> columns:
* The SQL standard says the default scale should be 0, <tt>:scale</tt> <=
  <tt>:precision</tt>, and makes no comments about the requirements of
  <tt>:precision</tt>.
* MySQL: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..30].
  Default is (10,0).
* PostgreSQL: <tt>:precision</tt> [1..infinity],
  <tt>:scale</tt> [0..infinity]. No default.
* SQLite2: Any <tt>:precision</tt> and <tt>:scale</tt> may be used.
  Internal storage as strings. No default.
* SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>,
  but the maximum supported <tt>:precision</tt> is 16. No default.
* Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127].
  Default is (38,0).
* DB2: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..62].
  Default unknown.
* Firebird: <tt>:precision</tt> [1..18], <tt>:scale</tt> [0..18].
  Default (9,0). Internal types NUMERIC and DECIMAL have different
  storage rules, decimal being better.
* FrontBase?: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  Default (38,0). WARNING Max <tt>:precision</tt>/<tt>:scale</tt> for
  NUMERIC is 19, and DECIMAL is 38.
* SqlServer?: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  Default (38,0).
* Sybase: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  Default (38,0).
* OpenBase?: Documentation unclear. Claims storage in <tt>double</tt>.

This method returns <tt>self</tt>.

== Examples
 # Assuming +td+ is an instance of TableDefinition
 td.column(:granted, :boolean)
 # granted BOOLEAN

 td.column(:picture, :binary, :limit => 2.megabytes)
 # => picture BLOB(2097152)

 td.column(:sales_stage, :string, :limit => 20, :default => 'new', :null => false)
 # => sales_stage VARCHAR(20) DEFAULT 'new' NOT NULL

 td.column(:bill_gates_money, :decimal, :precision => 15, :scale => 2)
 # => bill_gates_money DECIMAL(15,2)

 td.column(:sensor_reading, :decimal, :precision => 30, :scale => 20)
 # => sensor_reading DECIMAL(30,20)

 # While <tt>:scale</tt> defaults to zero on most databases, it
 # probably wouldn't hurt to include it.
 td.column(:huge_integer, :decimal, :precision => 30)
 # => huge_integer DECIMAL(30)

 # Defines a column with a database-specific type.
 td.column(:foo, 'polygon')
 # => foo polygon

== Short-hand examples

Instead of calling +column+ directly, you can also work with the short-hand definitions for the default types.
They use the type as the method name instead of as a parameter and allow for multiple columns to be defined
in a single statement.

What can be written like this with the regular calls to column:

  create_table "products", :force => true do |t|
    t.column "shop_id",    :integer
    t.column "creator_id", :integer
    t.column "name",       :string,   :default => "Untitled"
    t.column "value",      :string,   :default => "Untitled"
    t.column "created_at", :datetime
    t.column "updated_at", :datetime
  end

Can also be written as follows using the short-hand:

  create_table :products do |t|
    t.integer :shop_id, :creator_id
    t.string  :name, :value, :default => "Untitled"
    t.timestamps
  end

There's a short-hand method for each of the type values declared at the top. And then there's
TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.

TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type
column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of
options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option
will also create an index, similar to calling <tt>add_index</tt>. So what can be written like this:

  create_table :taggings do |t|
    t.integer :tag_id, :tagger_id, :taggable_id
    t.string  :tagger_type
    t.string  :taggable_type, :default => 'Photo'
  end
  add_index :taggings, :tag_id, :name => 'index_taggings_on_tag_id'
  add_index :taggings, [:tagger_id, :tagger_type]

Can also be written as follows using references:

  create_table :taggings do |t|
    t.references :tag, :index => { :name => 'index_taggings_on_tag_id' }
    t.references :tagger, :polymorphic => true, :index => true
    t.references :taggable, :polymorphic => { :default => 'Photo' }
  end




