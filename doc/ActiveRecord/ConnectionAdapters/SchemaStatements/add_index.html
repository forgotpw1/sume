<h1>ActiveRecord::ConnectionAdapters::SchemaStatements#add_index</h1>

Adds a new index to the table. +column_name+ can be a single Symbol, or
an Array of Symbols.

The index will be named after the table and the column name(s), unless
you pass <tt>:name</tt> as an option.

====== Creating a simple index
 add_index(:suppliers, :name)
generates
 CREATE INDEX suppliers_name_index ON suppliers(name)

====== Creating a unique index
 add_index(:accounts, [:branch_id, :party_id], :unique => true)
generates
 CREATE UNIQUE INDEX accounts_branch_id_party_id_index ON accounts(branch_id, party_id)

====== Creating a named index
 add_index(:accounts, [:branch_id, :party_id], :unique => true, :name => 'by_branch_party')
generates
 CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)

====== Creating an index with specific key length
 add_index(:accounts, :name, :name => 'by_name', :length => 10)
generates
 CREATE INDEX by_name ON accounts(name(10))

 add_index(:accounts, [:name, :surname], :name => 'by_name_surname', :length => {:name => 10, :surname => 15})
generates
 CREATE INDEX by_name_surname ON accounts(name(10), surname(15))

Note: SQLite doesn't support index length

====== Creating an index with a sort order (desc or asc, asc is the default)
 add_index(:accounts, [:branch_id, :party_id, :surname], :order => {:branch_id => :desc, :party_id => :asc})
generates
 CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)

Note: mysql doesn't yet support index order (it accepts the syntax but ignores it)

====== Creating a partial index
 add_index(:accounts, [:branch_id, :party_id], :unique => true, :where => "active")
generates
 CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active

Note: only supported by PostgreSQL




