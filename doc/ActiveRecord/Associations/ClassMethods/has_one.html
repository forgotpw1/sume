<h1>ActiveRecord::Associations::ClassMethods#has_one</h1>

Specifies a one-to-one association with another class. This method should only be used
if the other class contains the foreign key. If the current class contains the foreign key,
then you should use +belongs_to+ instead. See also ActiveRecord::Associations::ClassMethods's overview
on when to use has_one and when to use belongs_to.

The following methods for retrieval and query of a single associated object will be added:

[association(force_reload = false)]
  Returns the associated object. +nil+ is returned if none is found.
[association=(associate)]
  Assigns the associate object, extracts the primary key, sets it as the foreign key,
  and saves the associate object.
[build_association(attributes = {})]
  Returns a new object of the associated type that has been instantiated
  with +attributes+ and linked to this object through a foreign key, but has not
  yet been saved.
[create_association(attributes = {})]
  Returns a new object of the associated type that has been instantiated
  with +attributes+, linked to this object through a foreign key, and that
  has already been saved (if it passed the validation).
[create_association!(attributes = {})]
  Does the same as <tt>create_association</tt>, but raises <tt>ActiveRecord::RecordInvalid</tt>
  if the record is invalid.

(+association+ is replaced with the symbol passed as the first argument, so
<tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.)

=== Example

An Account class declares <tt>has_one :beneficiary</tt>, which will add:
* <tt>Account#beneficiary</tt> (similar to <tt>Beneficiary.first(:conditions => "account_id = #{id}")</tt>)
* <tt>Account#beneficiary=(beneficiary)</tt> (similar to <tt>beneficiary.account_id = account.id; beneficiary.save</tt>)
* <tt>Account#build_beneficiary</tt> (similar to <tt>Beneficiary.new("account_id" => id)</tt>)
* <tt>Account#create_beneficiary</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save; b</tt>)
* <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save!; b</tt>)

=== Options

The declaration can also include an options hash to specialize the behavior of the association.

Options are:
[:class_name]
  Specify the class name of the association. Use it only if that name can't be inferred
  from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but
  if the real class name is Person, you'll have to specify it with this option.
[:conditions]
  Specify the conditions that the associated object must meet in order to be included as a +WHERE+
  SQL fragment, such as <tt>rank = 5</tt>. Record creation from the association is scoped if a hash
  is used. <tt>has_one :account, :conditions => {:enabled => true}</tt> will create
  an enabled account with <tt>@company.create_account</tt> or <tt>@company.build_account</tt>.
[:order]
  Specify the order in which the associated objects are returned as an <tt>ORDER BY</tt> SQL fragment,
  such as <tt>last_name, first_name DESC</tt>.
[:dependent]
  If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to
  <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method.
  If set to <tt>:nullify</tt>, the associated object's foreign key is set to +NULL+.
  If set to <tt>:restrict</tt>, an error will be added to the object, preventing its deletion, if an
  associated object is present.
[:foreign_key]
  Specify the foreign key used for the association. By default this is guessed to be the name
  of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_one+ association
  will use "person_id" as the default <tt>:foreign_key</tt>.
[:primary_key]
  Specify the method that returns the primary key used for the association. By default this is +id+.
[:include]
  Specify second-order associations that should be eager loaded when this object is loaded.
[:as]
  Specifies a polymorphic interface (See <tt>belongs_to</tt>).
[:select]
  By default, this is <tt>*</tt> as in <tt>SELECT * FROM</tt>, but can be changed if
  you want to do a join but not include the joined columns, for example. Do not forget to include the
  primary and foreign keys, otherwise it will raise an error.
[:through]
  Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,
  <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the
  source reflection. You can only use a <tt>:through</tt> query through a <tt>has_one</tt>
  or <tt>belongs_to</tt> association on the join model.
[:source]
  Specifies the source association name used by <tt>has_one :through</tt> queries.
  Only use it if the name cannot be inferred from the association.
  <tt>has_one :favorite, :through => :favorites</tt> will look for a
  <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given.
[:source_type]
  Specifies type of the source association used by <tt>has_one :through</tt> queries where the source
  association is a polymorphic +belongs_to+.
[:readonly]
  If true, the associated object is readonly through the association.
[:validate]
  If +false+, don't validate the associated object when saving the parent object. +false+ by default.
[:autosave]
  If true, always save the associated object or destroy it if marked for destruction,
  when saving the parent object. If false, never save or destroy the associated object.
  By default, only save the associated object if it's a new record.
[:inverse_of]
  Specifies the name of the <tt>belongs_to</tt> association on the associated object
  that is the inverse of this <tt>has_one</tt> association. Does not work in combination
  with <tt>:through</tt> or <tt>:as</tt> options.
  See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.

Option examples:
  has_one :credit_card, :dependent => :destroy  # destroys the associated credit card
  has_one :credit_card, :dependent => :nullify  # updates the associated records foreign
                                                # key value to NULL rather than destroying it
  has_one :last_comment, :class_name => "Comment", :order => "posted_on"
  has_one :project_manager, :class_name => "Person", :conditions => "role = 'project_manager'"
  has_one :attachment, :as => :attachable
  has_one :boss, :readonly => :true
  has_one :club, :through => :membership
  has_one :primary_address, :through => :addressables, :conditions => ["addressable.primary = ?", true], :source => :addressable




