<h1>ActiveRecord::Associations::ClassMethods#has_many</h1>

Specifies a one-to-many association. The following methods for retrieval and query of
collections of associated objects will be added:

[collection(force_reload = false)]
  Returns an array of all the associated objects.
  An empty array is returned if none are found.
[collection<<(object, ...)]
  Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
  Note that this operation instantly fires update sql without waiting for the save or update call on the
  parent object.
[collection.delete(object, ...)]
  Removes one or more objects from the collection by setting their foreign keys to +NULL+.
  Objects will be in addition destroyed if they're associated with <tt>:dependent => :destroy</tt>,
  and deleted if they're associated with <tt>:dependent => :delete_all</tt>.

  If the <tt>:through</tt> option is used, then the join records are deleted (rather than
  nullified) by default, but you can specify <tt>:dependent => :destroy</tt> or
  <tt>:dependent => :nullify</tt> to override this.
[collection=objects]
  Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt>
  option is true callbacks in the join models are triggered except destroy callbacks, since deletion is
  direct.
[collection_singular_ids]
  Returns an array of the associated objects' ids
[collection_singular_ids=ids]
  Replace the collection with the objects identified by the primary keys in +ids+. This
  method loads the models and calls <tt>collection=</tt>. See above.
[collection.clear]
  Removes every object from the collection. This destroys the associated objects if they
  are associated with <tt>:dependent => :destroy</tt>, deletes them directly from the
  database if <tt>:dependent => :delete_all</tt>, otherwise sets their foreign keys to +NULL+.
  If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
  Join models are directly deleted.
[collection.empty?]
  Returns +true+ if there are no associated objects.
[collection.size]
  Returns the number of associated objects.
[collection.find(...)]
  Finds an associated object according to the same rules as ActiveRecord::Base.find.
[collection.exists?(...)]
  Checks whether an associated object with the given conditions exists.
  Uses the same rules as ActiveRecord::Base.exists?.
[collection.build(attributes = {}, ...)]
  Returns one or more new objects of the collection type that have been instantiated
  with +attributes+ and linked to this object through a foreign key, but have not yet
  been saved.
[collection.create(attributes = {})]
  Returns a new object of the collection type that has been instantiated
  with +attributes+, linked to this object through a foreign key, and that has already
  been saved (if it passed the validation). *Note*: This only works if the base model
  already exists in the DB, not if it is a new (unsaved) record!

(*Note*: +collection+ is replaced with the symbol passed as the first argument, so
<tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.)

=== Example

Example: A Firm class declares <tt>has_many :clients</tt>, which will add:
* <tt>Firm#clients</tt> (similar to <tt>Clients.all :conditions => ["firm_id = ?", id]</tt>)
* <tt>Firm#clients<<</tt>
* <tt>Firm#clients.delete</tt>
* <tt>Firm#clients=</tt>
* <tt>Firm#client_ids</tt>
* <tt>Firm#client_ids=</tt>
* <tt>Firm#clients.clear</tt>
* <tt>Firm#clients.empty?</tt> (similar to <tt>firm.clients.size == 0</tt>)
* <tt>Firm#clients.size</tt> (similar to <tt>Client.count "firm_id = #{id}"</tt>)
* <tt>Firm#clients.find</tt> (similar to <tt>Client.find(id, :conditions => "firm_id = #{id}")</tt>)
* <tt>Firm#clients.exists?(:name => 'ACME')</tt> (similar to <tt>Client.exists?(:name => 'ACME', :firm_id => firm.id)</tt>)
* <tt>Firm#clients.build</tt> (similar to <tt>Client.new("firm_id" => id)</tt>)
* <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save; c</tt>)
The declaration can also include an options hash to specialize the behavior of the association.

=== Options
[:class_name]
  Specify the class name of the association. Use it only if that name can't be inferred
  from the association name. So <tt>has_many :products</tt> will by default be linked
  to the Product class, but if the real class name is SpecialProduct, you'll have to
  specify it with this option.
[:conditions]
  Specify the conditions that the associated objects must meet in order to be included as a +WHERE+
  SQL fragment, such as <tt>price > 5 AND name LIKE 'B%'</tt>. Record creations from
  the association are scoped if a hash is used.
  <tt>has_many :posts, :conditions => {:published => true}</tt> will create published
  posts with <tt>@blog.posts.create</tt> or <tt>@blog.posts.build</tt>.
[:order]
  Specify the order in which the associated objects are returned as an <tt>ORDER BY</tt> SQL fragment,
  such as <tt>last_name, first_name DESC</tt>.
[:foreign_key]
  Specify the foreign key used for the association. By default this is guessed to be the name
  of this class in lower-case and "_id" suffixed. So a Person class that makes a +has_many+
  association will use "person_id" as the default <tt>:foreign_key</tt>.
[:primary_key]
  Specify the method that returns the primary key used for the association. By default this is +id+.
[:dependent]
  If set to <tt>:destroy</tt> all the associated objects are destroyed
  alongside this object by calling their +destroy+ method. If set to <tt>:delete_all</tt> all associated
  objects are deleted *without* calling their +destroy+ method. If set to <tt>:nullify</tt> all associated
  objects' foreign keys are set to +NULL+ *without* calling their +save+ callbacks. If set to
  <tt>:restrict</tt> an error will be added to the object, preventing its deletion, if any associated 
  objects are present.

  If using with the <tt>:through</tt> option, the association on the join model must be
  a +belongs_to+, and the records which get deleted are the join records, rather than
  the associated records.

[:finder_sql]
  Specify a complete SQL statement to fetch the association. This is a good way to go for complex
  associations that depend on multiple tables. May be supplied as a string or a proc where interpolation is
  required. Note: When this option is used, +find_in_collection+
  is _not_ added.
[:counter_sql]
  Specify a complete SQL statement to fetch the size of the association. If <tt>:finder_sql</tt> is
  specified but not <tt>:counter_sql</tt>, <tt>:counter_sql</tt> will be generated by
  replacing <tt>SELECT ... FROM</tt> with <tt>SELECT COUNT(*) FROM</tt>.
[:extend]
  Specify a named module for extending the proxy. See "Association extensions".
[:include]
  Specify second-order associations that should be eager loaded when the collection is loaded.
[:group]
  An attribute name by which the result should be grouped. Uses the <tt>GROUP BY</tt> SQL-clause.
[:having]
  Combined with +:group+ this can be used to filter the records that a <tt>GROUP BY</tt>
  returns. Uses the <tt>HAVING</tt> SQL-clause.
[:limit]
  An integer determining the limit on the number of rows that should be returned.
[:offset]
  An integer determining the offset from where the rows should be fetched. So at 5,
  it would skip the first 4 rows.
[:select]
  By default, this is <tt>*</tt> as in <tt>SELECT * FROM</tt>, but can be changed if
  you want to do a join but not include the joined columns, for example. Do not forget
  to include the primary and foreign keys, otherwise it will raise an error.
[:as]
  Specifies a polymorphic interface (See <tt>belongs_to</tt>).
[:through]
  Specifies an association through which to perform the query. This can be any other type
  of association, including other <tt>:through</tt> associations. Options for <tt>:class_name</tt>,
  <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the
  source reflection.

  If the association on the join model is a +belongs_to+, the collection can be modified
  and the records on the <tt>:through</tt> model will be automatically created and removed
  as appropriate. Otherwise, the collection is read-only, so you should manipulate the
  <tt>:through</tt> association directly.

  If you are going to modify the association (rather than just read from it), then it is
  a good idea to set the <tt>:inverse_of</tt> option on the source association on the
  join model. This allows associated records to be built which will automatically create
  the appropriate join model records when they are saved. (See the 'Association Join Models'
  section above.)
[:source]
  Specifies the source association name used by <tt>has_many :through</tt> queries.
  Only use it if the name cannot be inferred from the association.
  <tt>has_many :subscribers, :through => :subscriptions</tt> will look for either <tt>:subscribers</tt> or
  <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given.
[:source_type]
  Specifies type of the source association used by <tt>has_many :through</tt> queries where the source
  association is a polymorphic +belongs_to+.
[:uniq]
  If true, duplicates will be omitted from the collection. Useful in conjunction with <tt>:through</tt>.
[:readonly]
  If true, all the associated objects are readonly through the association.
[:validate]
  If +false+, don't validate the associated objects when saving the parent object. true by default.
[:autosave]
  If true, always save the associated objects or destroy them if marked for destruction,
  when saving the parent object. If false, never save or destroy the associated objects.
  By default, only save associated objects that are new records.
[:inverse_of]
  Specifies the name of the <tt>belongs_to</tt> association on the associated object
  that is the inverse of this <tt>has_many</tt> association. Does not work in combination
  with <tt>:through</tt> or <tt>:as</tt> options.
  See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.

Option examples:
  has_many :comments, :order => "posted_on"
  has_many :comments, :include => :author
  has_many :people, :class_name => "Person", :conditions => "deleted = 0", :order => "name"
  has_many :tracks, :order => "position", :dependent => :destroy
  has_many :comments, :dependent => :nullify
  has_many :tags, :as => :taggable
  has_many :reports, :readonly => true
  has_many :subscribers, :through => :subscriptions, :source => :user
  has_many :subscribers, :class_name => "Person", :finder_sql => Proc.new {
      %Q{
        SELECT DISTINCT *
        FROM people p, post_subscriptions ps
        WHERE ps.post_id = #{id} AND ps.person_id = p.id
        ORDER BY p.first_name
      }
  }




