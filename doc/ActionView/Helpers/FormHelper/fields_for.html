<h1>ActionView::Helpers::FormHelper#fields_for</h1>

Creates a scope around a specific model object like form_for, but
doesn't create the form tags themselves. This makes fields_for suitable
for specifying additional model objects in the same form.

=== Generic Examples

Although the usage and purpose of +field_for+ is similar to +form_for+'s,
its method signature is slightly different. Like +form_for+, it yields
a FormBuilder object associated with a particular model object to a block,
and within the block allows methods to be called on the builder to
generate fields associated with the model object. Fields may reflect
a model object in two ways - how they are named (hence how submitted
values appear within the +params+ hash in the controller) and what
default values are shown when the form the fields appear in is first
displayed. In order for both of these features to be specified independently,
both an object name (represented by either a symbol or string) and the
object itself can be passed to the method separately -

  <%= form_for @person do |person_form| %>
    First name: <%= person_form.text_field :first_name %>
    Last name : <%= person_form.text_field :last_name %>

    <%= fields_for :permission, @person.permission do |permission_fields| %>
      Admin?  : <%= permission_fields.check_box :admin %>
    <% end %>

    <%= f.submit %>
  <% end %>

In this case, the checkbox field will be represented by an HTML +input+
tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted
value will appear in the controller as <tt>params[:permission][:admin]</tt>.
If <tt>@person.permission</tt> is an existing record with an attribute
+admin+, the initial state of the checkbox when first displayed will
reflect the value of <tt>@person.permission.admin</tt>.

Often this can be simplified by passing just the name of the model
object to +fields_for+ -

  <%= fields_for :permission do |permission_fields| %>
    Admin?: <%= permission_fields.check_box :admin %>
  <% end %>

...in which case, if <tt>:permission</tt> also happens to be the name of an
instance variable <tt>@permission</tt>, the initial state of the input
field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.

Alternatively, you can pass just the model object itself (if the first
argument isn't a string or symbol +fields_for+ will realize that the
name has been omitted) -

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?: <%= permission_fields.check_box :admin %>
  <% end %>

and +fields_for+ will derive the required name of the field from the
_class_ of the model object, e.g. if <tt>@person.permission</tt>, is
of class +Permission+, the field will still be named <tt>permission[admin]</tt>.

Note: This also works for the methods in FormOptionHelper and
DateHelper that are designed to work with an object as base, like
FormOptionHelper#collection_select and DateHelper#datetime_select.

=== Nested Attributes Examples

When the object belonging to the current scope has a nested attribute
writer for a certain attribute, fields_for will yield a new scope
for that attribute. This allows you to create forms that set or change
the attributes of a parent object and its associations in one go.

Nested attribute writers are normal setter methods named after an
association. The most common way of defining these writers is either
with +accepts_nested_attributes_for+ in a model definition or by
defining a method with the proper name. For example: the attribute
writer for the association <tt>:address</tt> is called
<tt>address_attributes=</tt>.

Whether a one-to-one or one-to-many style form builder will be yielded
depends on whether the normal reader method returns a _single_ object
or an _array_ of objects.

==== One-to-one

Consider a Person class which returns a _single_ Address from the
<tt>address</tt> reader method and responds to the
<tt>address_attributes=</tt> writer method:

  class Person
    def address
      @address
    end

    def address_attributes=(attributes)
      # Process the attributes hash
    end
  end

This model can now be used with a nested fields_for, like so:

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :address do |address_fields| %>
      Street  : <%= address_fields.text_field :street %>
      Zip code: <%= address_fields.text_field :zip_code %>
    <% end %>
    ...
  <% end %>

When address is already an association on a Person you can use
+accepts_nested_attributes_for+ to define the writer method for you:

  class Person < ActiveRecord::Base
    has_one :address
    accepts_nested_attributes_for :address
  end

If you want to destroy the associated model through the form, you have
to enable it first using the <tt>:allow_destroy</tt> option for
+accepts_nested_attributes_for+:

  class Person < ActiveRecord::Base
    has_one :address
    accepts_nested_attributes_for :address, :allow_destroy => true
  end

Now, when you use a form element with the <tt>_destroy</tt> parameter,
with a value that evaluates to +true+, you will destroy the associated
model (eg. 1, '1', true, or 'true'):

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :address do |address_fields| %>
      ...
      Delete: <%= address_fields.check_box :_destroy %>
    <% end %>
    ...
  <% end %>

==== One-to-many

Consider a Person class which returns an _array_ of Project instances
from the <tt>projects</tt> reader method and responds to the
<tt>projects_attributes=</tt> writer method:

  class Person
    def projects
      [@project1, @project2]
    end

    def projects_attributes=(attributes)
      # Process the attributes hash
    end
  end

Note that the <tt>projects_attributes=</tt> writer method is in fact
required for fields_for to correctly identify <tt>:projects</tt> as a
collection, and the correct indices to be set in the form markup.

When projects is already an association on Person you can use
+accepts_nested_attributes_for+ to define the writer method for you:

  class Person < ActiveRecord::Base
    has_many :projects
    accepts_nested_attributes_for :projects
  end

This model can now be used with a nested fields_for. The block given to
the nested fields_for call will be repeated for each instance in the
collection:

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :projects do |project_fields| %>
      <% if project_fields.object.active? %>
        Name: <%= project_fields.text_field :name %>
      <% end %>
    <% end %>
    ...
  <% end %>

It's also possible to specify the instance to be used:

  <%= form_for @person do |person_form| %>
    ...
    <% @person.projects.each do |project| %>
      <% if project.active? %>
        <%= person_form.fields_for :projects, project do |project_fields| %>
          Name: <%= project_fields.text_field :name %>
        <% end %>
      <% end %>
    <% end %>
    ...
  <% end %>

Or a collection to be used:

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :projects, @active_projects do |project_fields| %>
      Name: <%= project_fields.text_field :name %>
    <% end %>
    ...
  <% end %>

When projects is already an association on Person you can use
+accepts_nested_attributes_for+ to define the writer method for you:

  class Person < ActiveRecord::Base
    has_many :projects
    accepts_nested_attributes_for :projects
  end

If you want to destroy any of the associated models through the
form, you have to enable it first using the <tt>:allow_destroy</tt>
option for +accepts_nested_attributes_for+:

  class Person < ActiveRecord::Base
    has_many :projects
    accepts_nested_attributes_for :projects, :allow_destroy => true
  end

This will allow you to specify which models to destroy in the
attributes hash by adding a form element for the <tt>_destroy</tt>
parameter with a value that evaluates to +true+
(eg. 1, '1', true, or 'true'):

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :projects do |project_fields| %>
      Delete: <%= project_fields.check_box :_destroy %>
    <% end %>
    ...
  <% end %>

When a collection is used you might want to know the index of each
object into the array. For this purpose, the <tt>index</tt> method
is available in the FormBuilder object.

  <%= form_for @person do |person_form| %>
    ...
    <%= person_form.fields_for :projects do |project_fields| %>
      Project #<%= project_fields.index %>
      ...
    <% end %>
    ...
  <% end %>




