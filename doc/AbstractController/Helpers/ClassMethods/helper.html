<h1>AbstractController::Helpers::ClassMethods#helper</h1>


<p>The <tt>helper</tt> class method can take a series of helper module names,
a block, or both.</p>

<h4>Parameters</h4>
<ul><li>
<p><tt>*args</tt> - Module, Symbol, String, :all</p>
</li><li>
<p><tt>block</tt> - A block defining helper methods</p>
</li></ul>

<h4>Examples</h4>

<p>When the argument is a module it will be included directly in the template
class.</p>

<pre>helper FooHelper # =&gt; includes FooHelper</pre>

<p>When the argument is a string or symbol, the method will provide the
"_helper" suffix, require the file and include the module in the template
class.  The second form illustrates how to include custom helpers when
working with namespaced controllers, or other cases where the file
containing the helper definition is not in one of Rails' standard load
paths:</p>

<pre>helper :foo             # =&gt; requires 'foo_helper' and includes FooHelper
helper 'resources/foo'  # =&gt; requires 'resources/foo_helper' and includes Resources::FooHelper</pre>

<p>Additionally, the <tt>helper</tt> class method can receive and evaluate a
block, making the methods defined available to the template.</p>

<pre># One line
helper { def hello() &quot;Hello, world!&quot; end }

# Multi-line
helper do
  def foo(bar)
    &quot;#{bar} is the very best&quot;
  end
end</pre>

<p>Finally, all the above styles can be mixed together, and the
<tt>helper</tt> method can be invoked with a mix of <tt>symbols</tt>,
<tt>strings</tt>, <tt>modules</tt> and blocks.</p>

<pre>helper(:three, BlindHelper) { def mice() 'mice' end }</pre>





