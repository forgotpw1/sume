<h1>ActiveModel::MassAssignmentSecurity::ClassMethods#attr_protected</h1>

Attributes named in this macro are protected from mass-assignment
whenever attributes are sanitized before assignment. A role for the
attributes is optional, if no role is provided then :default is used.
A role can be defined by using the :as option with a symbol or an array of symbols as the value.

Mass-assignment to these attributes will simply be ignored, to assign
to them you can use direct writer methods. This is meant to protect
sensitive attributes from being overwritten by malicious users
tampering with URLs or forms. Example:

  class Customer
    include ActiveModel::MassAssignmentSecurity

    attr_accessor :name, :email, :logins_count

    attr_protected :logins_count
    # Suppose that admin can not change email for customer
    attr_protected :logins_count, :email, :as => :admin

    def assign_attributes(values, options = {})
      sanitize_for_mass_assignment(values, options[:as]).each do |k, v|
        send("#{k}=", v)
      end
    end
  end

When using the :default role:

  customer = Customer.new
  customer.assign_attributes({ "name" => "David", "email" => "a@b.com", :logins_count => 5 }, :as => :default)
  customer.name          # => "David"
  customer.email # => "a@b.com"
  customer.logins_count    # => nil

And using the :admin role:

  customer = Customer.new
  customer.assign_attributes({ "name" => "David", "email" => "a@b.com", :logins_count => 5}, :as => :admin)
  customer.name          # => "David"
  customer.email # => nil
  customer.logins_count    # => nil

  customer.email = "c@d.com"
  customer.email # => "c@d.com"

To start from an all-closed default and enable attributes as needed,
have a look at +attr_accessible+.

Note that using <tt>Hash#except</tt> or <tt>Hash#slice</tt> in place of
+attr_protected+ to sanitize attributes provides basically the same
functionality, but it makes a bit tricky to deal with nested attributes.




