<h1>ActiveModel::MassAssignmentSecurity::ClassMethods#attr_accessible</h1>

Specifies a white list of model attributes that can be set via
mass-assignment.

Like +attr_protected+, a role for the attributes is optional,
if no role is provided then :default is used. A role can be defined by
using the :as option with a symbol or an array of symbols as the value.

This is the opposite of the +attr_protected+ macro: Mass-assignment
will only set attributes in this list, to assign to the rest of
attributes you can use direct writer methods. This is meant to protect
sensitive attributes from being overwritten by malicious users
tampering with URLs or forms. If you'd rather start from an all-open
default and restrict attributes as needed, have a look at
+attr_protected+.

  class Customer
    include ActiveModel::MassAssignmentSecurity

    attr_accessor :name, :credit_rating

    attr_accessible :name
    attr_accessible :name, :credit_rating, :as => :admin

    def assign_attributes(values, options = {})
      sanitize_for_mass_assignment(values, options[:as]).each do |k, v|
        send("#{k}=", v)
      end
    end
  end

When using the :default role:

  customer = Customer.new
  customer.assign_attributes({ "name" => "David", "credit_rating" => "Excellent", :last_login => 1.day.ago }, :as => :default)
  customer.name          # => "David"
  customer.credit_rating # => nil

  customer.credit_rating = "Average"
  customer.credit_rating # => "Average"

And using the :admin role:

  customer = Customer.new
  customer.assign_attributes({ "name" => "David", "credit_rating" => "Excellent", :last_login => 1.day.ago }, :as => :admin)
  customer.name          # => "David"
  customer.credit_rating # => "Excellent"

Note that using <tt>Hash#except</tt> or <tt>Hash#slice</tt> in place of
+attr_accessible+ to sanitize attributes provides basically the same
functionality, but it makes a bit tricky to deal with nested attributes.




