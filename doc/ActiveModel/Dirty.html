== Active Model Dirty

Provides a way to track changes in your object in the same way as
Active Record does.

The requirements for implementing ActiveModel::Dirty are:

* <tt>include ActiveModel::Dirty</tt> in your object
* Call <tt>define_attribute_methods</tt> passing each method you want to
  track
* Call <tt>attr_name_will_change!</tt> before each change to the tracked
  attribute

If you wish to also track previous changes on save or update, you need to
add

  @previously_changed = changes

inside of your save or update method.

A minimal implementation could be:

  class Person

    include ActiveModel::Dirty

    define_attribute_methods :name

    def name
      @name
    end

    def name=(val)
      name_will_change! unless val == @name
      @name = val
    end

    def save
      @previously_changed = changes
      @changed_attributes.clear
    end

  end

== Examples:

A newly instantiated object is unchanged:
  person = Person.find_by_name('Uncle Bob')
  person.changed?       # => false

Change the name:
  person.name = 'Bob'
  person.changed?       # => true
  person.name_changed?  # => true
  person.name_was       # => 'Uncle Bob'
  person.name_change    # => ['Uncle Bob', 'Bob']
  person.name = 'Bill'
  person.name_change    # => ['Uncle Bob', 'Bill']

Save the changes:
  person.save
  person.changed?       # => false
  person.name_changed?  # => false

Assigning the same value leaves the attribute unchanged:
  person.name = 'Bill'
  person.name_changed?  # => false
  person.name_change    # => nil

Which attributes have changed?
  person.name = 'Bob'
  person.changed        # => ['name']
  person.changes        # => { 'name' => ['Bill', 'Bob'] }

If an attribute is modified in-place then make use of <tt>[attribute_name]_will_change!</tt>
to mark that the attribute is changing. Otherwise ActiveModel can't track changes to
in-place attributes.

  person.name_will_change!
  person.name_change    # => ['Bill', 'Bill']
  person.name << 'y'
  person.name_change    # => ['Bill', 'Billy']

